# Анализ чанкинга сообщений и рекомендации

Файл: `scripts/import-watcher-smart.py`
Ключевые функции: `ChunkGenerator.create_chunks()`, `ChunkGenerator._finalize_chunk()`

## Текущее поведение
* __Критерии разбиения__ (`ChunkGenerator.create_chunks()`):
  - __Размер__: новый чанк при `len(current_chunk) >= CHUNK_SIZE` (дефолт: 10 сообщений, из env `CHUNK_SIZE`).
  - __Переход ролей__: новый чанк при переходе `user -> assistant`.
  - __Время__: новый чанк, если с начала чанка до текущего сообщения прошло более 30 минут.
* __Формирование текста__: `combined_text` — конкатенация контента сообщений без явной разметки ролей.
* __Оценка длины__: `tokens_estimate = len(combined_text.split())` — грубая оценка по словам.
* __Идентификатор чанка__: `chunk_id` детерминированный по `project_name`, `sessionId`, исходному `timestamp` и первым 100 символам `combined_text` (sha256, усечённый до 16 hex-символов).

## Оценка оптимальности
* __Граница по ролям неудачна__: разбиение на переходе `user -> assistant` часто отрезает связку «вопрос+ответ», разнося её на два чанка. Это снижает семантическую целостность и качество ретрива.
* __Лимит по сообщениям вместо токенов__: 10 сообщений могут существенно превышать оптимальный диапазон для эмбеддингов `all-MiniLM-L6-v2` (~256–384 токенов). Это ведёт к обрезке или деградации качества представлений.
* __Потеря структуры диалога__: в `combined_text` нет префиксов ролей («User: … / Assistant: …»), что затрудняет ретрив и интерпретацию.
* __Разрыв по времени считается от начала чанка__: полезнее также проверять большой разрыв между соседними сообщениями, а не только «от начала».
* __Коллизии chunk_id маловероятны__, но усечение до 16 hex теоретически повышает риск при больших объёмах.

## Рекомендации
1. __Изменить границу по ролям__:
   - Делить на переходе `assistant -> user`, чтобы чанк обычно содержал связку «вопрос+ответ» целиком.

2. __Добавить разметку ролей в `combined_text`__:
   - Форматировать как:
     ```
     User: <сообщение>
     Assistant: <сообщение>
     ```
   - Сохранить порядок и структуру.

3. __Ограничивать длину по токенам/символам__:
   - Минимально: добавить «жёсткий» лимит по символам (например, 3000–4000) при сборке чанка.
   - Предпочтительно: оценивать токены библиотекой, совместимой с моделью, и держать ~250–350 токенов на чанк.

4. __Делить по разрыву между соседними сообщениями__:
   - Если gap между `prev.timestamp` и `curr.timestamp` > 30 минут (или иной порог), начинать новый чанк, даже если с начала чанка прошло меньше.

5. __Уточнить оценку токенов__:
   - Заменить `len(text.split())` на более реалистичную оценку (например, по символам/байтам или через токенизатор модели), чтобы лучше контролировать размер чанка.

6. __Идентификатор чанка__ (опционально):
   - Можно увеличить длину префикса sha256 (например, до 24–32 hex-символов) для ещё меньшего риска коллизий.

## Возможные улучшения «на перспективу»
* __Скольжение окна и overlap__: небольшой overlap (например, 10–15%) между соседними чанками повышает полноту ретрива.
* __Семантическое разбиение__: разрывать на смысловых границах (например, детектировать завершение ответа ассистента), а не только по фиксированным правилам.

## Приоритет внедрения
1. __Быстрые победы__ (минимальные изменения):
   - Перенести сплит на `assistant -> user`.
   - Добавить префиксы ролей в `combined_text`.
   - Добавить жёсткий лимит по символам.

2. __Улучшения средней сложности__:
   - Добавить сплит по разрыву между соседями.
   - Улучшить оценку токенов.

3. __Расширенные__:
   - Реализовать overlap.
   - Перейти на реальный токенизатор модели и динамический контроль токенов.

## Ожидаемый эффект
* __Лучшее семантическое покрытие__: «вопрос+ответ» в одном чанке повышают релевантность поиска.
* __Стабильный размер чанков__: снижение риска обрезки и «размазывания» смысла.
* __Повышение качества ретрива__: за счёт разметки ролей и корректных границ.

## Ссылки на код
* `scripts/import-watcher-smart.py`
  - `ChunkGenerator.create_chunks()`
  - `ChunkGenerator._finalize_chunk()`
